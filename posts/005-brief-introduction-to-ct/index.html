<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Alex Simkin">
    <meta name="description" content="Alex Simkin&#39;s personal website">
    <meta name="keywords" content="blog,developer,personal">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Brief introduction to Category theory"/>
<meta name="twitter:description" content="Let&rsquo;s briefly talk about Category theory. Category theory is a branch of set theory where the focus was shifted on relationships between sets rather than sets themselves. So, in category theory, we say that all sets are an atomic object that we can&rsquo;t look into and all relationships between sets are arrows that go from one atomic object to another with a few extra rules. First, all objects must have at least one identity arrow id: A -&gt; A that starts and ends on the same object."/>

    <meta property="og:title" content="Brief introduction to Category theory" />
<meta property="og:description" content="Let&rsquo;s briefly talk about Category theory. Category theory is a branch of set theory where the focus was shifted on relationships between sets rather than sets themselves. So, in category theory, we say that all sets are an atomic object that we can&rsquo;t look into and all relationships between sets are arrows that go from one atomic object to another with a few extra rules. First, all objects must have at least one identity arrow id: A -&gt; A that starts and ends on the same object." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://SimY4.github.io/posts/005-brief-introduction-to-ct/" />
<meta property="article:published_time" content="2019-02-22T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2019-02-22T00:00:00&#43;00:00"/>


    
      <base href="https://SimY4.github.io/posts/005-brief-introduction-to-ct/">
    
    <title>
  Brief introduction to Category theory · My personal space
</title>

    
      <link rel="canonical" href="https://SimY4.github.io/posts/005-brief-introduction-to-ct/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://SimY4.github.io/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    

    

    <link rel="icon" type="image/png" href="https://SimY4.github.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://SimY4.github.io/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.55.4" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://SimY4.github.io">
      My personal space
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://SimY4.github.io/posts/">Blog</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://SimY4.github.io/index.xml">RSS</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">Brief introduction to Category theory</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2019-02-22T00:00:00Z'>
                February 22, 2019
              </time>
            </span>
            <span class="reading-time">
              <i class="fas fa-clock"></i>
              3 minutes read
            </span>
          </div>
          <div class="categories">
  <i class="fas fa-folder"></i>
    <a href="https://SimY4.github.io/categories/fp/">fp</a></div>

          <div class="tags">
  <i class="fas fa-tag"></i>
    <a href="https://SimY4.github.io/tags/fp/">fp</a></div>

        </div>
      </header>

      <div>
        <p>Let&rsquo;s briefly talk about Category theory. Category theory is a branch of set theory where the focus was shifted on relationships between sets rather than sets themselves. So, in category theory, we say that all sets are an atomic object that we can&rsquo;t look into and all relationships between sets are arrows that go from one atomic object to another with a few extra rules. First, all objects must have at least one identity arrow <code>id: A -&gt; A</code> that starts and ends on the same object. Second, all arrows have to be composable, meaning that if you have two arrows <code>f: A -&gt; B</code> and <code>g: B -&gt; C</code> there should always be at least one arrow <code>g . f: A -&gt; C</code> and these compositions must be associative (<code>(f . g) . h == f . (g . h)</code>). It&rsquo;s pretty much all we need to know at this point, having these rules we can model them in scala:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala">  <span style="font-style:italic">// Parameterized with a type with two type holes in it
</span><span style="font-style:italic"></span>  <span style="font-style:italic">//           \/
</span><span style="font-style:italic"></span><span style="font-weight:bold">trait</span> <span style="font-weight:bold">Category</span>[<span style="">F</span>[<span style="font-weight:bold">_</span>, <span style="font-weight:bold">_</span>]] {
  <span style="font-weight:bold">def</span> id[<span style="">A</span>]<span style="font-weight:bold">:</span> <span style="">F</span>[<span style="">A</span>, <span style="">A</span>]
  <span style="font-weight:bold">def</span> compose[<span style="">A</span>, <span style="">B</span>, <span style="">C</span>](f<span style="font-weight:bold">:</span> <span style="">F</span>[<span style="">A</span>, <span style="">B</span>], g<span style="font-weight:bold">:</span> <span style="">F</span>[<span style="">B</span>, <span style="">C</span>])<span style="font-weight:bold">:</span> <span style="">F</span>[<span style="">A</span>, <span style="">C</span>] 
}

<span style="font-weight:bold">object</span> <span style="font-weight:bold">Category</span> <span style="font-weight:bold">extends</span> <span style="font-weight:bold">CategoryInstances0</span> <span style="font-weight:bold">with</span> <span style="font-weight:bold">CategoryInstances1</span></code></pre></div>
<p>Given this definition of a category, we can implement a few the most frequently used examples of categories:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="font-weight:bold">trait</span> <span style="font-weight:bold">CategoryInstances0</span> {
  <span style="font-style:italic">// Function1 category instance
</span><span style="font-style:italic"></span>  <span style="font-weight:bold">implicit</span> <span style="font-weight:bold">val</span> functionsCategory<span style="font-weight:bold">:</span> <span style="">Category</span>[<span style="">Function1</span>] <span style="font-weight:bold">=</span> <span style="font-weight:bold">new</span> <span style="font-weight:bold">Category</span>[<span style="">Function1</span>] {
    <span style="font-weight:bold">def</span> id[<span style="">A</span>]<span style="font-weight:bold">:</span> <span style="">A</span> =&gt; A <span style="font-weight:bold">=</span> identity
    <span style="font-weight:bold">def</span> compose[<span style="">A</span>, <span style="">B</span>, <span style="">C</span>](f<span style="font-weight:bold">:</span> <span style="">A</span> =&gt; B, g<span style="font-weight:bold">:</span> <span style="">B</span> =&gt; C)<span style="font-weight:bold">:</span> <span style="">A</span> =&gt; C <span style="font-weight:bold">=</span> g compose f
  }

  <span style="font-style:italic">// Type hierarchy category instance
</span><span style="font-style:italic"></span>  <span style="font-style:italic">//      &lt;:&lt;[-A, +B] is an standard type evidence that A is a subtype of B
</span><span style="font-style:italic"></span>  <span style="font-style:italic">//                                           \/
</span><span style="font-style:italic"></span>  <span style="font-weight:bold">implicit</span> <span style="font-weight:bold">val</span> typeHierarchyCategory<span style="font-weight:bold">:</span> <span style="">Category</span>[<span style="font-weight:bold">&lt;:</span><span style="">&lt;</span>] <span style="font-weight:bold">=</span> <span style="font-weight:bold">new</span> <span style="font-weight:bold">Category</span>[<span style="font-weight:bold">&lt;:</span><span style="">&lt;</span>] {
    <span style="font-weight:bold">def</span> id[<span style="">A</span>]<span style="font-weight:bold">:</span> <span style="">A</span> <span style="font-weight:bold">&lt;:</span><span style="">&lt;</span> <span style="">A</span> = implicitly[<span style="">A</span> <span style="font-weight:bold">&lt;:</span><span style="">&lt;</span> <span style="">A</span>] <span style="font-style:italic">// A is always a subtype of itself
</span><span style="font-style:italic"></span>    <span style="font-weight:bold">def</span> compose[<span style="">A</span>, <span style="">B</span>, <span style="">C</span>](f<span style="font-weight:bold">:</span> <span style="">A</span> <span style="font-weight:bold">&lt;:</span><span style="">&lt;</span> <span style="">B</span>, g<span style="font-weight:bold">:</span> <span style="">B</span> <span style="font-weight:bold">&lt;:</span><span style="">&lt;</span> <span style="">C</span>)<span style="font-weight:bold">:</span> <span style="">A</span> <span style="font-weight:bold">&lt;:</span><span style="">&lt;</span> <span style="">C</span> = g compose f
  }
}</code></pre></div>
<p>A category with a single object is called monoid. Now, let&rsquo;s try to define the Kleisli category in a generic way. To do this we&rsquo;ll need one extra helper trait with some standard scala plumbing to make it into a nice syntax.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="font-weight:bold">trait</span> <span style="font-weight:bold">Shmancy</span>[<span style="">F</span>[<span style="font-weight:bold">_</span>]] {
  <span style="font-weight:bold">def</span> pure[<span style="">A</span>](a<span style="font-weight:bold">:</span> <span style="">A</span>)<span style="font-weight:bold">:</span> <span style="">F</span>[<span style="">A</span>]
  <span style="font-weight:bold">def</span> &gt;&gt;=[<span style="">A</span>, <span style="">B</span>](f<span style="font-weight:bold">:</span> <span style="">A</span> =&gt; F[<span style="">B</span>])<span style="font-weight:bold">:</span> <span style="">F</span>[<span style="">A</span>] <span style="font-weight:bold">=&gt;</span> F[<span style="">B</span>]
}

<span style="font-weight:bold">object</span> <span style="font-weight:bold">Shmancy</span> {
  <span style="font-weight:bold">implicit</span> <span style="font-weight:bold">class</span> <span style="font-weight:bold">ShmancyOp</span>[<span style="">F</span>[<span style="font-weight:bold">_</span>], <span style="">A</span>, <span style="">B</span>](<span style="font-weight:bold">private</span> <span style="font-weight:bold">val</span> fa<span style="font-weight:bold">:</span> <span style="">F</span>[<span style="">A</span>]) <span style="font-weight:bold">extends</span> <span style="font-weight:bold">AnyVal</span> { 
    <span style="font-weight:bold">def</span> &gt;&gt;=[<span style="">B</span>](f<span style="font-weight:bold">:</span> <span style="">A</span> =&gt; F[<span style="">B</span>])(<span style="font-weight:bold">implicit</span> F<span style="font-weight:bold">:</span> <span style="">Shmancy</span>[<span style="">F</span>])<span style="font-weight:bold">:</span> <span style="">F</span>[<span style="">B</span>] <span style="font-weight:bold">=</span> 
      F.&gt;&gt;=(f)(fa)
  }
}

<span style="font-weight:bold">trait</span> <span style="font-weight:bold">CategoryInstances1</span> {
  <span style="font-style:italic">// Kleisli category instance
</span><span style="font-style:italic"></span>  <span style="font-style:italic">//                 Type lamdba that encodes type constructor [A, B] =&gt; Function1[A, F[B]]
</span><span style="font-style:italic"></span>  <span style="font-style:italic">//                                                                         \/
</span><span style="font-style:italic"></span>  <span style="font-weight:bold">implicit</span> <span style="font-weight:bold">def</span> kleisliCategory[<span style="">F</span>[<span style="font-weight:bold">_</span>]](<span style="font-weight:bold">implicit</span> F<span style="font-weight:bold">:</span> <span style="">Shmancy</span>[<span style="">F</span>])<span style="font-weight:bold">:</span> <span style="">Category</span>[({ <span style="font-weight:bold">type</span> <span style="">T</span>[<span style="">A</span>, <span style="">B</span>] <span style="">=</span> <span style="">Function1</span>[<span style="">A</span>, <span style="">F</span>[<span style="">B</span>]] })<span style="font-weight:bold">#</span><span style="">T</span>] <span style="font-weight:bold">=</span> 
    <span style="font-weight:bold">new</span> <span style="font-weight:bold">Category</span>[({ <span style="font-weight:bold">type</span> <span style="">T</span>[<span style="">A</span>, <span style="">B</span>] <span style="">=</span> <span style="">Function1</span>[<span style="">A</span>, <span style="">F</span>[<span style="">B</span>]] })<span style="font-weight:bold">#</span><span style="">T</span>] {
      <span style="font-weight:bold">def</span> id[<span style="">A</span>]<span style="font-weight:bold">:</span> <span style="">A</span> =&gt; F[<span style="">A</span>] <span style="font-weight:bold">=</span> F.pure <span style="font-weight:bold">_</span>
      <span style="font-weight:bold">def</span> compose[<span style="">A</span>, <span style="">B</span>, <span style="">C</span>](f<span style="font-weight:bold">:</span> <span style="">A</span> =&gt; F[<span style="">B</span>], g<span style="font-weight:bold">:</span> <span style="">B</span> =&gt; F[<span style="">C</span>])<span style="font-weight:bold">:</span> <span style="">A</span> =&gt; F[<span style="">C</span>] <span style="font-weight:bold">=</span> { a <span style="font-weight:bold">=&gt;</span> f(a) &gt;&gt;= g }
    }
}</code></pre></div>
<p>Here we are. So, to make things compose in Kleisly category we need only two things, a function that can lift a pure value into an effect <code>F[_]</code> and a binding function that can apply function <code>A =&gt; F[B]</code> to <code>F[A]</code>. This definition is called a monad.</p>

      </div>

      <footer>
        


        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "actinglikecrazy" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
     © 2019
    
       · 
      Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
    
  </section>
</footer>

    </main>

    

  </body>

</html>
