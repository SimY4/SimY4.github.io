<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fp on My personal space</title>
    <link>https://SimY4.github.io/tags/fp/</link>
    <description>Recent content in fp on My personal space</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 01 Feb 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://SimY4.github.io/tags/fp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Monads Explained</title>
      <link>https://SimY4.github.io/posts/002-monads-explained/</link>
      <pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://SimY4.github.io/posts/002-monads-explained/</guid>
      <description>Referential transparency Link to heading Referential transparency is a nice property of pure functional programming languages that allow us to reason about the behaviour of our programs. It guarantees that all expressions are always evaluating to the same result in any context. What it gives to the programmer is an ease of equational reasoning about any pure program as they used to do it in math.
2 + (2 * 2) === 2 + 4 === 6 &amp;#34;Hello&amp;#34; + &amp;#34; &amp;#34; + &amp;#34;world&amp;#34; === &amp;#34;Hello &amp;#34; + &amp;#34;world&amp;#34; === &amp;#34;Hello&amp;#34; + &amp;#34; world&amp;#34; === &amp;#34;Hello world&amp;#34; List(1, 2, 3) ++ List(4, 5, 6) === List(1, 2, 3, 4, 5, 6) g(f(a)) === (g compose f)(a) If you think about it, most of the modern compilers (non-FP included) can already do some optimisations for referentially transparent code fragments.</description>
    </item>
    
  </channel>
</rss>
